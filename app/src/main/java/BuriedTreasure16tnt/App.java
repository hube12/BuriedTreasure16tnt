/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package BuriedTreasure16tnt;

import com.seedfinding.latticg.reversal.DynamicProgram;
import com.seedfinding.latticg.reversal.calltype.java.JavaCalls;
import com.seedfinding.latticg.util.LCG;
import kaptainwutax.featureutils.GenerationContext;
import kaptainwutax.featureutils.loot.ChestContent;
import kaptainwutax.featureutils.loot.item.Items;
import kaptainwutax.featureutils.structure.BuriedTreasure;
import kaptainwutax.featureutils.structure.generator.Generator;
import kaptainwutax.featureutils.structure.generator.Generators;
import kaptainwutax.mcutils.rand.ChunkRand;
import kaptainwutax.mcutils.rand.seed.StructureSeed;
import kaptainwutax.mcutils.util.math.NextLongReverser;
import kaptainwutax.mcutils.util.pos.CPos;
import kaptainwutax.mcutils.version.MCVersion;
import mjtb49.hashreversals.ChunkRandomReverser;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import static kaptainwutax.mcutils.state.Dimension.OVERWORLD;

public class App {
	public static List<Long> getAllCorrectLootSeeds() {
		DynamicProgram dynamicProgram = DynamicProgram.create(LCG.JAVA);
		// Nothing on First Roll (heart of sea)
		// Second roll should be 8 on nextInt(8-5+1=4)+5
		dynamicProgram.add(JavaCalls.nextInt(4).equalTo(3));
		for (int i = 0; i < 8; i++) {
			dynamicProgram.add(JavaCalls.nextInt(35).betweenII(30, 34));
			dynamicProgram.add(JavaCalls.nextInt(2).equalTo(1));
		}

		return dynamicProgram.reverse().boxed().parallel()
				.peek(System.out::println)
				.collect(Collectors.toList());
	}

	public static void processLootSeeds(long lootSeed) {
		MCVersion version = MCVersion.v1_16_5;
		long seed = lootSeed ^ LCG.JAVA.multiplier;
		List<Long> preLongSeeds = NextLongReverser.getSeeds(seed);

		BuriedTreasure buriedTreasure = new BuriedTreasure(version);
		ChunkRand rand = new ChunkRand();
		int rs = buriedTreasure.getSpacing();
		for (long preLongSeed : preLongSeeds) {
			long popSeed = ChunkRandomReverser.reverseDecoratorSeed(preLongSeed ^ LCG.JAVA.multiplier, 1, 3, version);
			for (int cx = -10; cx < 10; cx++) {
				for (int cz = -10; cz < 10; cz++) {
					List<Long> decoSeed = ChunkRandomReverser.reversePopulationSeed(popSeed, cx * 16, cz * 16, version);
					for (long s : decoSeed) {
						// to check correct seed
//                        rand.setDecoratorSeed(s, cx * 16, cz * 16, 30001, version);
//                        long ss = rand.nextLong();
//                        System.out.println((ss & Mth.MASK_48) );
						CPos p = buriedTreasure.getInRegion(s, cx / rs, cz / rs, rand);
						int chunkX = cx;
						int chunkZ = cz;
						if (p != null) {
							StructureSeed.getWorldSeeds(s).asStream().boxed().parallel().forEach(ws -> {
								GenerationContext.Context context = GenerationContext.getContext(ws, OVERWORLD, version);
								if (buriedTreasure.canSpawn(chunkX, chunkZ, context.getBiomeSource())) {
									Generator generator = Generators.get(buriedTreasure.getClass()).create(version);
									generator.generate(context.getGenerator(), chunkX, chunkZ);
									List<ChestContent> loots = buriedTreasure.getLoot(s, generator, false);
									assert loots.size() == 1;
									if (!loots.get(0).containsAtLeast(Items.TNT, 16)) {
										System.err.println("Error " + loots + " " + lootSeed + " " + p);
									}
								}
							});
						}
					}
				}
			}
		}
	}

	public static List<Long> makeLootSeeds() {
		List<Long> lootSeeds = getAllCorrectLootSeeds();
		try {
			File file = new File("seeds.txt");
			if (file.createNewFile()) {
				System.out.println("File created: " + file.getName());
				FileWriter fileWriter = new FileWriter(file);
				for (Long seed : lootSeeds) {
					fileWriter.write(seed + "\n");
				}
			} else {
				System.out.println("File already exists.");
			}
		} catch (IOException e) {
			System.out.println("An error occurred.");
			e.printStackTrace();
		}
		return lootSeeds;
	}

	public static void main(String[] args) {
		List<Long> lootSeeds = makeLootSeeds();
		for (Long lootSeed : lootSeeds) {
			processLootSeeds(lootSeed);
		}
	}
}
